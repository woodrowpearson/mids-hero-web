# Epic 1.4: API Client Integration - Implementation Plan

**Date**: 2025-11-16
**Status**: Planning Complete
**Epic**: 1.4 - API Client Integration
**Previous Epic**: 1.3 - Layout Shell + Navigation

---

## Table of Contents

1. [Background & Context](#background--context)
2. [Objectives](#objectives)
3. [Component Specifications](#component-specifications)
4. [State Management Plan](#state-management-plan)
5. [API Integration Plan](#api-integration-plan)
6. [Implementation Tasks](#implementation-tasks)
7. [Testing Strategy](#testing-strategy)
8. [Acceptance Criteria](#acceptance-criteria)
9. [Visual Verification](#visual-verification)

---

## Background & Context

### Previous Epic

**Epic 1.3** established the layout structure with BuildLayout, TopPanel, SidePanel, and routing. The foundation is now in place for data integration.

**Reference**: `docs/frontend/plans/PLAN-SUMMARY-epic-1.3.md`

### MidsReborn Analysis

MidsReborn loads all game data upfront at application startup using synchronous binary file reads. Data is cached in a singleton for the entire app lifecycle with no reloading.

**Key Insights from Analysis**:
- **Aggressive caching**: Load once, cache forever (data rarely changes)
- **Sequential loading**: Archetypes → Powersets → Powers → Enhancements
- **No lazy loading**: All data loaded upfront (3000+ powers, 3000+ enhancements)
- **Fatal error handling**: Application exits on data load failures
- **Blocking UI**: Splash screen during synchronous loads

**Reference**: `docs/frontend/analysis/MIDSREBORN-UI-ANALYSIS-epic-1.4.md`

### Web Implementation Strategy

Unlike MidsReborn's blocking synchronous loads, we'll use:
- **TanStack Query** for async data fetching with automatic caching
- **Lazy loading** by archetype/powerset to reduce initial load
- **Pagination** for large datasets (enhancements)
- **Graceful error handling** with retry buttons
- **Progressive loading** with Suspense boundaries

---

## Objectives

From `docs/frontend/epic-breakdown.md` (Epic 1.4):

### Primary Objectives

1. **Connect to FastAPI backend** at `http://localhost:8000/api`
2. **Create API service layers** for powers, enhancements, archetypes, calculations
3. **Implement TanStack Query hooks** for data fetching with caching
4. **Add loading and error states** for all async operations

### Deliverables

**API Service Layers**:
- `services/api.ts` - Base Axios client with interceptors
- `services/archetypeApi.ts` - Archetype data operations
- `services/powersetApi.ts` - Powerset data operations
- `services/powerApi.ts` - Power data operations
- `services/enhancementApi.ts` - Enhancement data operations
- `services/calculationApi.ts` - Calculation endpoints

**TanStack Query Hooks**:
- `hooks/useArchetypes.ts` - Fetch all archetypes
- `hooks/usePowersets.ts` - Fetch powersets (filtered by archetype)
- `hooks/usePowers.ts` - Fetch powers (lazy by powerset)
- `hooks/useEnhancements.ts` - Fetch enhancements (paginated)
- `hooks/useCalculations.ts` - Trigger calculations

**UI Components**:
- `components/ui/LoadingSpinner.tsx` - Loading indicator
- `components/ui/ErrorMessage.tsx` - Error display with retry
- `components/ui/LoadingState.tsx` - Full-page loading state
- `components/ui/EmptyState.tsx` - Empty/no data state

### Success Criteria

✅ Can fetch archetypes from backend
✅ Can fetch powersets filtered by archetype
✅ Can fetch powers by powerset
✅ Can fetch enhancements with pagination
✅ Error handling works (network failures, API errors)
✅ Data caches correctly (no unnecessary refetches)
✅ Loading states display during async operations
✅ All components tested (>80% coverage)

---

## Component Specifications

### 1. Base API Client (`services/api.ts`)

**Purpose**: Centralized Axios client with request/response interceptors

**TypeScript Interface**:
```typescript
// services/api.ts
import axios, { AxiosInstance, AxiosError, InternalAxiosRequestConfig } from 'axios';

const api: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000/api',
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000, // 10 second timeout
});

// Request interceptor (add auth if needed later)
api.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    // Future: Add auth token
    // const token = localStorage.getItem('auth_token');
    // if (token) {
    //   config.headers.Authorization = `Bearer ${token}`;
    // }
    return config;
  },
  (error: AxiosError) => Promise.reject(error)
);

// Response interceptor (error handling)
api.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    console.error('API Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

export default api;
```

**Testing Strategy**:
- Mock Axios for testing
- Test timeout handling
- Test error response formats
- Test request headers

---

### 2. Archetype API Service (`services/archetypeApi.ts`)

**Purpose**: Fetch archetype data from backend

**TypeScript Interface**:
```typescript
// services/archetypeApi.ts
import api from './api';
import { Archetype } from '@/types/character.types';

export interface ArchetypeResponse {
  id: number;
  name: string;
  display_name: string;
  primary_category: string;
  secondary_category: string;
  // ... other fields
}

export const archetypeApi = {
  /**
   * Fetch all archetypes
   * Endpoint: GET /api/archetypes
   */
  async getAll(): Promise<Archetype[]> {
    const response = await api.get<Archetype[]>('/archetypes');
    return response.data;
  },

  /**
   * Fetch single archetype by ID
   * Endpoint: GET /api/archetypes/:id
   */
  async getById(id: number): Promise<Archetype> {
    const response = await api.get<Archetype>(`/archetypes/${id}`);
    return response.data;
  },
};
```

**Error Handling**:
- Network failures: Retry 3 times with exponential backoff
- 404: Return empty array
- 500: Throw error with user-friendly message

**Testing**:
- Test successful fetch
- Test network error handling
- Test empty response
- Test malformed data

---

### 3. Powerset API Service (`services/powersetApi.ts`)

**Purpose**: Fetch powerset data, optionally filtered by archetype

**TypeScript Interface**:
```typescript
// services/powersetApi.ts
import api from './api';
import { Powerset } from '@/types/power.types';

export const powersetApi = {
  /**
   * Fetch all powersets (optional archetype filter)
   * Endpoint: GET /api/powersets?archetype_id=X
   */
  async getAll(archetypeId?: number): Promise<Powerset[]> {
    const params = archetypeId ? { archetype_id: archetypeId } : {};
    const response = await api.get<Powerset[]>('/powersets', { params });
    return response.data;
  },

  /**
   * Fetch powersets for specific archetype
   * Endpoint: GET /api/archetypes/:id/powersets
   */
  async getByArchetype(archetypeId: number): Promise<Powerset[]> {
    const response = await api.get<Powerset[]>(`/archetypes/${archetypeId}/powersets`);
    return response.data;
  },

  /**
   * Fetch single powerset by ID
   * Endpoint: GET /api/powersets/:id
   */
  async getById(id: number): Promise<Powerset> {
    const response = await api.get<Powerset>(`/powersets/${id}`);
    return response.data;
  },
};
```

**Caching Strategy**:
- `staleTime: Infinity` (powersets rarely change)
- Cache per archetype ID

---

### 4. Power API Service (`services/powerApi.ts`)

**Purpose**: Fetch powers within a powerset (lazy loading)

**TypeScript Interface**:
```typescript
// services/powerApi.ts
import api from './api';
import { Power } from '@/types/power.types';

export const powerApi = {
  /**
   * Fetch powers in a powerset
   * Endpoint: GET /api/powersets/:id/powers
   */
  async getByPowerset(powersetId: number): Promise<Power[]> {
    const response = await api.get<Power[]>(`/powersets/${powersetId}/powers`);
    return response.data;
  },

  /**
   * Fetch single power by ID
   * Endpoint: GET /api/powers/:id
   */
  async getById(id: number): Promise<Power> {
    const response = await api.get<Power>(`/powers/${id}`);
    return response.data;
  },
};
```

**Lazy Loading**:
- Only fetch when user selects a powerset
- Cache per powerset ID
- `staleTime: 5 minutes`

---

### 5. Enhancement API Service (`services/enhancementApi.ts`)

**Purpose**: Fetch enhancements with pagination and filtering

**TypeScript Interface**:
```typescript
// services/enhancementApi.ts
import api from './api';
import { Enhancement, EnhancementType } from '@/types/enhancement.types';

export interface EnhancementFilters {
  type?: EnhancementType;
  grade?: number;
  search?: string;
  page?: number;
  limit?: number;
}

export interface PaginatedEnhancementsResponse {
  data: Enhancement[];
  total: number;
  page: number;
  limit: number;
  has_more: boolean;
}

export const enhancementApi = {
  /**
   * Fetch enhancements with pagination
   * Endpoint: GET /api/enhancements?page=1&limit=100&type=X&grade=Y
   */
  async getAll(filters: EnhancementFilters = {}): Promise<PaginatedEnhancementsResponse> {
    const params = {
      page: filters.page || 1,
      limit: filters.limit || 100,
      ...(filters.type && { type: filters.type }),
      ...(filters.grade && { grade: filters.grade }),
      ...(filters.search && { search: filters.search }),
    };
    const response = await api.get<PaginatedEnhancementsResponse>('/enhancements', { params });
    return response.data;
  },

  /**
   * Fetch single enhancement by ID
   * Endpoint: GET /api/enhancements/:id
   */
  async getById(id: number): Promise<Enhancement> {
    const response = await api.get<Enhancement>(`/enhancements/${id}`);
    return response.data;
  },
};
```

**Pagination**:
- Default: 100 enhancements per page
- Client-side filtering for performance
- `staleTime: 1 hour` (enhancements rarely change)

---

### 6. Calculation API Service (`services/calculationApi.ts`)

**Purpose**: Trigger backend calculations for build totals

**TypeScript Interface**:
```typescript
// services/calculationApi.ts
import api from './api';
import { BuildData, CalculatedTotals } from '@/types/build.types';

export const calculationApi = {
  /**
   * Calculate build totals
   * Endpoint: POST /api/calculations/totals
   */
  async calculateTotals(buildData: BuildData): Promise<CalculatedTotals> {
    const response = await api.post<CalculatedTotals>('/calculations/totals', buildData);
    return response.data;
  },

  /**
   * Calculate single power stats
   * Endpoint: POST /api/calculations/power
   */
  async calculatePower(powerData: any): Promise<any> {
    const response = await api.post('/calculations/power', powerData);
    return response.data;
  },
};
```

**Caching**:
- No caching (always fresh calculations)
- Debounce client-side (200ms) to avoid excessive API calls

---

## State Management Plan

### TanStack Query Configuration

**Setup**: `app/providers.tsx`

```typescript
// app/providers.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 3,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      staleTime: 5 * 60 * 1000, // 5 minutes default
    },
  },
});

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### Query Hooks

#### `hooks/useArchetypes.ts`

```typescript
// hooks/useArchetypes.ts
import { useQuery } from '@tanstack/react-query';
import { archetypeApi } from '@/services/archetypeApi';

export function useArchetypes() {
  return useQuery({
    queryKey: ['archetypes'],
    queryFn: archetypeApi.getAll,
    staleTime: Infinity, // Archetypes never change
  });
}

export function useArchetype(id: number) {
  return useQuery({
    queryKey: ['archetype', id],
    queryFn: () => archetypeApi.getById(id),
    staleTime: Infinity,
    enabled: !!id,
  });
}
```

#### `hooks/usePowersets.ts`

```typescript
// hooks/usePowersets.ts
import { useQuery } from '@tanstack/react-query';
import { powersetApi } from '@/services/powersetApi';

export function usePowersets(archetypeId?: number) {
  return useQuery({
    queryKey: ['powersets', archetypeId],
    queryFn: () => powersetApi.getByArchetype(archetypeId!),
    staleTime: Infinity,
    enabled: !!archetypeId, // Only fetch when archetype selected
  });
}

export function usePowerset(id: number) {
  return useQuery({
    queryKey: ['powerset', id],
    queryFn: () => powersetApi.getById(id),
    staleTime: Infinity,
    enabled: !!id,
  });
}
```

#### `hooks/usePowers.ts`

```typescript
// hooks/usePowers.ts
import { useQuery } from '@tanstack/react-query';
import { powerApi } from '@/services/powerApi';

export function usePowers(powersetId?: number) {
  return useQuery({
    queryKey: ['powers', powersetId],
    queryFn: () => powerApi.getByPowerset(powersetId!),
    staleTime: 5 * 60 * 1000, // 5 minutes
    enabled: !!powersetId, // Lazy load when powerset selected
  });
}

export function usePower(id: number) {
  return useQuery({
    queryKey: ['power', id],
    queryFn: () => powerApi.getById(id),
    staleTime: 5 * 60 * 1000,
    enabled: !!id,
  });
}
```

#### `hooks/useEnhancements.ts`

```typescript
// hooks/useEnhancements.ts
import { useQuery } from '@tanstack/react-query';
import { enhancementApi, EnhancementFilters } from '@/services/enhancementApi';

export function useEnhancements(filters: EnhancementFilters = {}) {
  return useQuery({
    queryKey: ['enhancements', filters],
    queryFn: () => enhancementApi.getAll(filters),
    staleTime: 60 * 60 * 1000, // 1 hour
  });
}

export function useEnhancement(id: number) {
  return useQuery({
    queryKey: ['enhancement', id],
    queryFn: () => enhancementApi.getById(id),
    staleTime: 60 * 60 * 1000,
    enabled: !!id,
  });
}
```

#### `hooks/useCalculations.ts`

```typescript
// hooks/useCalculations.ts
import { useMutation } from '@tanstack/react-query';
import { calculationApi } from '@/services/calculationApi';
import { BuildData } from '@/types/build.types';

export function useCalculateTotals() {
  return useMutation({
    mutationFn: (buildData: BuildData) => calculationApi.calculateTotals(buildData),
    // No caching - always recalculate
  });
}
```

---

## API Integration Plan

### Backend Endpoints

All endpoints verified as existing in FastAPI backend:

| Endpoint | Method | Purpose | Response Type |
|----------|--------|---------|---------------|
| `/api/archetypes` | GET | Fetch all archetypes | `Archetype[]` |
| `/api/archetypes/:id` | GET | Fetch single archetype | `Archetype` |
| `/api/archetypes/:id/powersets` | GET | Powersets for archetype | `Powerset[]` |
| `/api/powersets` | GET | All powersets (optional filter) | `Powerset[]` |
| `/api/powersets/:id` | GET | Single powerset | `Powerset` |
| `/api/powersets/:id/powers` | GET | Powers in powerset | `Power[]` |
| `/api/powers/:id` | GET | Single power | `Power` |
| `/api/enhancements` | GET | Paginated enhancements | `PaginatedResponse` |
| `/api/enhancements/:id` | GET | Single enhancement | `Enhancement` |
| `/api/enhancement-sets` | GET | All enhancement sets | `EnhancementSet[]` |
| `/api/calculations/totals` | POST | Calculate build totals | `CalculatedTotals` |

### TypeScript Types

Define types matching backend response schemas:

**`types/character.types.ts`**:
```typescript
export interface Archetype {
  id: number;
  name: string;
  display_name: string;
  primary_category: string;
  secondary_category: string;
  // ... other fields
}

export interface Origin {
  id: number;
  name: string;
  display_name: string;
}

export type Alignment = 'hero' | 'villain';
```

**`types/power.types.ts`**:
```typescript
export interface Powerset {
  id: number;
  name: string;
  display_name: string;
  archetype_id: number;
  category: 'primary' | 'secondary' | 'pool' | 'epic' | 'ancillary';
}

export interface Power {
  id: number;
  name: string;
  display_name: string;
  powerset_id: number;
  level_available: number;
  // ... other fields
}
```

**`types/enhancement.types.ts`**:
```typescript
export enum EnhancementType {
  Normal = 'normal',
  SetIO = 'set_io',
  SpecialIO = 'special_io',
}

export interface Enhancement {
  id: number;
  name: string;
  type: EnhancementType;
  grade: number;
  // ... other fields
}

export interface EnhancementSet {
  id: number;
  name: string;
  enhancements: Enhancement[];
  bonuses: SetBonus[];
}
```

**`types/build.types.ts`**:
```typescript
export interface BuildData {
  archetype_id: number;
  origin_id?: number;
  alignment?: Alignment;
  powers: PowerEntry[];
  level: number;
}

export interface PowerEntry {
  power_id: number;
  level_taken: number;
  slots: SlotEntry[];
}

export interface SlotEntry {
  enhancement_id: number;
  level: number;
}

export interface CalculatedTotals {
  defense: DefenseStats;
  resistance: ResistanceStats;
  damage: DamageStats;
  // ... other stats
}
```

---

## Implementation Tasks

### Task 1: Setup Base API Client

**File**: `frontend/src/services/api.ts`

**Steps**:
1. Create Axios instance with baseURL from env
2. Add request interceptor for future auth
3. Add response interceptor for error logging
4. Set timeout to 10 seconds
5. Export configured instance

**Test**: `services/api.test.ts`
- Test baseURL configuration
- Test timeout handling
- Mock Axios for testing

---

### Task 2: Create API Service Layers

**Files**:
- `services/archetypeApi.ts`
- `services/powersetApi.ts`
- `services/powerApi.ts`
- `services/enhancementApi.ts`
- `services/calculationApi.ts`

**Steps for each**:
1. Import base API client
2. Define TypeScript interfaces for requests/responses
3. Implement API methods (getAll, getById, etc.)
4. Add JSDoc comments
5. Export service object

**Tests**: `services/*.test.ts`
- Mock API responses
- Test success paths
- Test error handling
- Test query params

---

### Task 3: Create TanStack Query Hooks

**Files**:
- `hooks/useArchetypes.ts`
- `hooks/usePowersets.ts`
- `hooks/usePowers.ts`
- `hooks/useEnhancements.ts`
- `hooks/useCalculations.ts`

**Steps for each**:
1. Import TanStack Query functions
2. Import corresponding API service
3. Define query key structure
4. Configure staleTime, retry, enabled flags
5. Export hooks

**Tests**: `hooks/*.test.ts`
- Use `@testing-library/react-hooks`
- Test loading state
- Test success state
- Test error state
- Test caching behavior

---

### Task 4: Create Loading Components

**File**: `components/ui/LoadingSpinner.tsx`

```typescript
// components/ui/LoadingSpinner.tsx
import { cn } from '@/lib/utils';

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export function LoadingSpinner({ size = 'md', className }: LoadingSpinnerProps) {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-8 w-8',
    lg: 'h-12 w-12',
  };

  return (
    <div
      className={cn(
        'animate-spin rounded-full border-b-2 border-gray-900',
        sizeClasses[size],
        className
      )}
    />
  );
}
```

**Test**: `components/ui/LoadingSpinner.test.tsx`
- Test rendering
- Test size variants
- Test className prop

---

**File**: `components/ui/ErrorMessage.tsx`

```typescript
// components/ui/ErrorMessage.tsx
import { Button } from '@/components/ui/button';
import { AlertCircle } from 'lucide-react';

interface ErrorMessageProps {
  title?: string;
  message: string;
  onRetry?: () => void;
}

export function ErrorMessage({ title = 'Error', message, onRetry }: ErrorMessageProps) {
  return (
    <div className="flex flex-col items-center justify-center p-8 text-center">
      <AlertCircle className="mb-4 h-12 w-12 text-red-500" />
      <h3 className="mb-2 text-lg font-semibold">{title}</h3>
      <p className="mb-4 text-sm text-gray-600">{message}</p>
      {onRetry && (
        <Button onClick={onRetry} variant="outline">
          Try Again
        </Button>
      )}
    </div>
  );
}
```

**Test**: `components/ui/ErrorMessage.test.tsx`
- Test rendering
- Test retry button click
- Test without retry button

---

**File**: `components/ui/LoadingState.tsx`

```typescript
// components/ui/LoadingState.tsx
import { LoadingSpinner } from './LoadingSpinner';

interface LoadingStateProps {
  message?: string;
}

export function LoadingState({ message = 'Loading...' }: LoadingStateProps) {
  return (
    <div className="flex flex-col items-center justify-center p-8">
      <LoadingSpinner size="lg" />
      <p className="mt-4 text-sm text-gray-600">{message}</p>
    </div>
  );
}
```

---

**File**: `components/ui/EmptyState.tsx`

```typescript
// components/ui/EmptyState.tsx
import { FileQuestion } from 'lucide-react';

interface EmptyStateProps {
  title?: string;
  message: string;
}

export function EmptyState({ title = 'No Data', message }: EmptyStateProps) {
  return (
    <div className="flex flex-col items-center justify-center p-8 text-center">
      <FileQuestion className="mb-4 h-12 w-12 text-gray-400" />
      <h3 className="mb-2 text-lg font-semibold text-gray-700">{title}</h3>
      <p className="text-sm text-gray-500">{message}</p>
    </div>
  );
}
```

---

### Task 5: Update Providers

**File**: `app/providers.tsx`

**Steps**:
1. Create QueryClient with configuration
2. Wrap children in QueryClientProvider
3. Add ReactQueryDevtools for development
4. Export Providers component

**Test**: Verify providers wrap app correctly

---

### Task 6: Install Dependencies

**Command**:
```bash
cd frontend
npm install @tanstack/react-query@latest
npm install @tanstack/react-query-devtools@latest --save-dev
npm install axios
npm install lucide-react  # For icons
```

---

### Task 7: Environment Variables

**File**: `frontend/.env.local`

```env
NEXT_PUBLIC_API_URL=http://localhost:8000/api
```

**File**: `frontend/.env.production`

```env
NEXT_PUBLIC_API_URL=https://api.midshero.com/api
```

---

### Task 8: Integration Testing

**Create example component**: `components/debug/ArchetypeList.tsx`

```typescript
// components/debug/ArchetypeList.tsx
import { useArchetypes } from '@/hooks/useArchetypes';
import { LoadingState } from '@/components/ui/LoadingState';
import { ErrorMessage } from '@/components/ui/ErrorMessage';
import { EmptyState } from '@/components/ui/EmptyState';

export function ArchetypeList() {
  const { data: archetypes, isLoading, error, refetch } = useArchetypes();

  if (isLoading) return <LoadingState message="Loading archetypes..." />;
  if (error) return <ErrorMessage message={(error as Error).message} onRetry={refetch} />;
  if (!archetypes || archetypes.length === 0) {
    return <EmptyState message="No archetypes found" />;
  }

  return (
    <div className="p-4">
      <h2 className="mb-4 text-xl font-bold">Archetypes</h2>
      <ul className="space-y-2">
        {archetypes.map((at) => (
          <li key={at.id} className="rounded border p-2">
            {at.display_name}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**Add to builder page**: `app/builder/page.tsx`

Test that:
- Archetypes load from backend
- Loading spinner shows during fetch
- Error message shows on failure
- Data displays when successful

---

## Testing Strategy

### Unit Tests

**Coverage Goal**: >80% for all services and hooks

**Tools**:
- Vitest
- React Testing Library
- `@testing-library/react-hooks` (for hook testing)
- Mock Service Worker (MSW) for API mocking

**Test Structure**:

```typescript
// Example: services/archetypeApi.test.ts
import { describe, it, expect, vi } from 'vitest';
import { archetypeApi } from './archetypeApi';
import api from './api';

vi.mock('./api');

describe('archetypeApi', () => {
  it('fetches all archetypes', async () => {
    const mockData = [{ id: 1, name: 'Tanker', display_name: 'Tanker' }];
    vi.mocked(api.get).mockResolvedValue({ data: mockData });

    const result = await archetypeApi.getAll();

    expect(api.get).toHaveBeenCalledWith('/archetypes');
    expect(result).toEqual(mockData);
  });

  it('handles errors gracefully', async () => {
    vi.mocked(api.get).mockRejectedValue(new Error('Network error'));

    await expect(archetypeApi.getAll()).rejects.toThrow('Network error');
  });
});
```

### Integration Tests

**Test API integration with backend**:

1. Start backend: `just dev` (from project root)
2. Run frontend tests with real API calls
3. Verify data fetching works end-to-end

### Component Tests

**Test loading/error components**:

```typescript
// Example: components/ui/ErrorMessage.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ErrorMessage } from './ErrorMessage';

describe('ErrorMessage', () => {
  it('renders error message', () => {
    render(<ErrorMessage message="Something went wrong" />);
    expect(screen.getByText('Something went wrong')).toBeInTheDocument();
  });

  it('calls onRetry when button clicked', async () => {
    const user = userEvent.setup();
    const onRetry = vi.fn();
    render(<ErrorMessage message="Error" onRetry={onRetry} />);

    await user.click(screen.getByText('Try Again'));

    expect(onRetry).toHaveBeenCalled();
  });
});
```

---

## Acceptance Criteria

### Functional

✅ **Data Fetching**:
- Can fetch archetypes from backend
- Can fetch powersets filtered by archetype ID
- Can fetch powers by powerset ID
- Can fetch enhancements with pagination

✅ **Caching**:
- Archetypes cached with `staleTime: Infinity`
- Powersets cached with `staleTime: Infinity`
- Powers cached with `staleTime: 5 minutes`
- Enhancements cached with `staleTime: 1 hour`

✅ **Error Handling**:
- Network errors show ErrorMessage component
- API errors (4xx, 5xx) show user-friendly messages
- Retry button triggers refetch

✅ **Loading States**:
- LoadingSpinner shows during data fetch
- LoadingState shows for full-page loads
- EmptyState shows when no data available

### Technical

✅ **TypeScript**:
- All API services typed with interfaces
- All hooks have proper TypeScript generics
- No `any` types (strict mode)

✅ **Tests**:
- All services have unit tests (>80% coverage)
- All hooks have tests
- All components have tests
- Integration tests with backend pass

✅ **Code Quality**:
- ESLint passing
- Prettier passing
- No console errors in dev mode

---

## Visual Verification

### Epic 1.4 Visual Verification Checklist

Epic 1.4 is about **API infrastructure**, not visual UI. However, we can verify data loading visually:

#### Test Scenario 1: Archetype List

**Steps**:
1. Navigate to `/builder`
2. Add `<ArchetypeList />` component temporarily
3. Observe loading state → data loads → archetypes display

**Expected**:
- ✅ LoadingSpinner shows briefly
- ✅ Archetypes load from backend
- ✅ List displays all archetypes (Tanker, Scrapper, etc.)

#### Test Scenario 2: Network Error

**Steps**:
1. Stop backend server
2. Refresh `/builder` page
3. Observe error state

**Expected**:
- ✅ ErrorMessage component displays
- ✅ "Try Again" button visible
- ✅ Clicking retry triggers refetch

#### Test Scenario 3: Empty State

**Steps**:
1. Mock API to return empty array
2. Observe empty state

**Expected**:
- ✅ EmptyState component displays
- ✅ "No data" message shown

### MidsReborn Reference

**Not applicable** - Epic 1.4 is backend integration, not UI replication.

**Screenshots**: None needed for this epic.

---

## Key Design Decisions

### Decision 1: Lazy Loading Over Upfront Loading

**Rationale**: MidsReborn loads all 3000+ powers upfront (blocking), but web can lazy load by powerset for better performance.

**Impact**: Faster initial load, reduced memory usage

**Implementation**: Use `enabled` flag in TanStack Query to defer loading until needed

---

### Decision 2: TanStack Query Over Manual State

**Rationale**: TanStack Query provides automatic caching, refetching, and error handling built-in.

**Impact**: Less boilerplate, better UX, automatic retry logic

**Implementation**: Configure QueryClient with sensible defaults

---

### Decision 3: Aggressive Caching for Static Data

**Rationale**: Archetypes, powersets rarely change. Cache indefinitely to avoid unnecessary API calls.

**Impact**: Reduced backend load, faster UX

**Implementation**: `staleTime: Infinity` for static data

---

### Decision 4: Pagination for Enhancements

**Rationale**: 3000+ enhancements is too large for single request.

**Impact**: Faster load times, better UX

**Implementation**: Backend pagination + client-side filtering

---

## Summary

Epic 1.4 establishes the **data fetching foundation** for Mids Hero Web:

✅ **API Client Setup**: Axios with interceptors, timeout, error handling
✅ **Service Layers**: Type-safe API wrappers for all endpoints
✅ **TanStack Query Hooks**: Automatic caching, refetching, loading states
✅ **UI Components**: Loading, error, empty state components
✅ **Lazy Loading**: Defer loading of powers/enhancements until needed
✅ **Aggressive Caching**: Static data cached indefinitely

The next epic (2.1) will build character creation UI on top of this data layer.

---

**Status**: ✅ Planning Complete - Ready for Execution
**Services**: 6 (api, archetypeApi, powersetApi, powerApi, enhancementApi, calculationApi)
**Hooks**: 5 (useArchetypes, usePowersets, usePowers, useEnhancements, useCalculations)
**Components**: 4 (LoadingSpinner, ErrorMessage, LoadingState, EmptyState)
**Tests**: ~40 tests
**Dependencies**: Epic 1.3 complete ✅
**Next**: Execute via implementation or direct coding
