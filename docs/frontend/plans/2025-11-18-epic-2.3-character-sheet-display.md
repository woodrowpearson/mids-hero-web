# Implementation Plan: Epic 2.3 - Character Sheet Display

**Date**: 2025-11-18
**Epic**: 2.3 - Character Sheet Display
**Status**: Planning
**MidsReborn Analysis**: docs/frontend/analysis/MIDSREBORN-UI-ANALYSIS-epic-2.3.md

---

## Background & Context

Epic 2.3 implements the character sheet display functionality for Mids Hero Web, providing users with a comprehensive view of their character's information, archetype modifiers, caps, and inherent powers. This epic builds on Epic 2.1 (Archetype & Origin Selection) and Epic 2.2 (Powerset Selection) to create a complete character summary panel.

### Links to Previous Work

- **Previous Epic**: docs/frontend/plans/PLAN-SUMMARY-epic-2.2.md (Powerset Selection)
- **MidsReborn Analysis**: docs/frontend/analysis/MIDSREBORN-UI-ANALYSIS-epic-2.3.md
- **Architecture**: docs/frontend/architecture.md
- **Epic Breakdown**: docs/frontend/epic-breakdown.md (Epic 2.3 section)

### MidsReborn Reference

From MIDSREBORN-UI-ANALYSIS-epic-2.3.md:

**Character Display**:
- Single summary label: `"{Name}: Level {level} {Origin} {Archetype} ({Primary} / {Secondary})"`
- Example: "Magic Blaster: Level 10 Magic Blaster (Archery / Tactical Arrow)"

**Archetype Caps** (7 types):
- HP Cap, Damage Cap, Resistance Cap, Defense Cap
- Regeneration Cap, Recovery Cap, Recharge Cap
- Varies by archetype (e.g., Brute damage cap = 775%, Tanker resistance cap = 90%)

**Archetype Base Modifiers** (4 types):
- Base HP (at level 50)
- Base Regeneration
- Base Recovery
- Base Threat (aggro modifier)

**Inherent Powers**:
- Retrieved from archetype's inherent powerset
- Displayed in priority order
- Examples: Fury (Brute), Defiance (Blaster), Gauntlet (Tanker), Critical Hit (Scrapper)

---

## Objectives

From epic-breakdown.md (Epic 2.3):

1. ✅ Create summary display of character info
2. ✅ Show archetype modifiers and caps
3. ✅ Display inherent powers
4. ✅ Implement edit mode vs. view mode

---

## Component Specifications

### 1. CharacterSheet.tsx (Main Container)

**Purpose**: Main container component that composes all character sheet subcomponents

**Props Interface**:
```typescript
interface CharacterSheetProps {
  mode?: 'view' | 'edit';  // Display mode (default: 'view')
  className?: string;
}
```

**Component Structure**:
```tsx
export function CharacterSheet({ mode = 'view', className }: CharacterSheetProps) {
  const character = useCharacterStore((state) => ({
    name: state.name,
    level: state.level,
    archetype: state.archetype,
    origin: state.origin,
    alignment: state.alignment,
    primaryPowerset: state.primaryPowerset,
    secondaryPowerset: state.secondaryPowerset,
  }));

  return (
    <Card className={cn('w-full', className)}>
      <CardHeader>
        <CardTitle>Character Sheet</CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Character Summary */}
        <CharacterSummary mode={mode} />

        {/* Archetype Info Tabs */}
        <Tabs defaultValue="modifiers">
          <TabsList>
            <TabsTrigger value="modifiers">Base Modifiers</TabsTrigger>
            <TabsTrigger value="caps">Caps</TabsTrigger>
            <TabsTrigger value="inherents">Inherent Powers</TabsTrigger>
          </TabsList>

          <TabsContent value="modifiers">
            <ATModifiersDisplay archetype={character.archetype} />
          </TabsContent>

          <TabsContent value="caps">
            <CapsDisplay archetype={character.archetype} />
          </TabsContent>

          <TabsContent value="inherents">
            <InherentPowersDisplay archetype={character.archetype} />
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}
```

**State Management**:
- Reads from `characterStore` (name, level, archetype, origin, alignment, powersets)
- No local state needed (all data from store)

**Tests**:
1. Renders with character data from store
2. Displays all child components correctly
3. Switches between tabs
4. Updates when store changes
5. Handles null archetype gracefully

---

### 2. CharacterSummary.tsx (Character Info Display)

**Purpose**: Display character summary in MidsReborn format with edit capabilities

**Props Interface**:
```typescript
interface CharacterSummaryProps {
  mode?: 'view' | 'edit';
  className?: string;
}
```

**Component Structure**:
```tsx
export function CharacterSummary({ mode = 'view', className }: CharacterSummaryProps) {
  const {
    name,
    level,
    origin,
    archetype,
    primaryPowerset,
    secondaryPowerset,
    setName,
    setLevel,
  } = useCharacterStore();

  const [isEditing, setIsEditing] = useState(mode === 'edit');

  // MidsReborn format: "{Name}: Level {level} {Origin} {Archetype} ({Primary} / {Secondary})"
  const summaryText = `${name || 'Unnamed'}: Level ${level} ${origin?.displayName || 'Unknown'} ${archetype?.displayName || 'Archetype'} (${primaryPowerset?.displayName || 'None'} / ${secondaryPowerset?.displayName || 'None'})`;

  return (
    <div className={cn('space-y-4', className)}>
      {isEditing ? (
        <>
          {/* Edit Mode */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="character-name">Character Name</Label>
              <Input
                id="character-name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Enter character name"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="character-level">Level</Label>
              <Input
                id="character-level"
                type="number"
                min={1}
                max={50}
                value={level}
                onChange={(e) => setLevel(parseInt(e.target.value, 10))}
              />
            </div>
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={() => setIsEditing(false)}
          >
            Done Editing
          </Button>
        </>
      ) : (
        <>
          {/* View Mode */}
          <div className="flex items-center justify-between">
            <p className="text-lg font-semibold">{summaryText}</p>
            {mode === 'edit' && (
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setIsEditing(true)}
              >
                <PencilIcon className="h-4 w-4 mr-2" />
                Edit
              </Button>
            )}
          </div>
        </>
      )}
    </div>
  );
}
```

**State Management**:
- Reads: name, level, origin, archetype, powersets from characterStore
- Updates: name, level via setName, setLevel actions
- Local state: isEditing (toggle between view/edit)

**Tests**:
1. Displays summary in MidsReborn format
2. Enters edit mode when Edit button clicked
3. Updates name in store on input change
4. Updates level in store on input change (1-50 range)
5. Exits edit mode when Done button clicked
6. Handles missing data gracefully (shows "Unnamed", "Unknown", etc.)

---

### 3. ATModifiersDisplay.tsx (Base Modifiers Table)

**Purpose**: Display archetype base modifiers (HP, regen, recovery, threat)

**Props Interface**:
```typescript
interface ATModifiersDisplayProps {
  archetype: Archetype | null;
  className?: string;
}
```

**Component Structure**:
```tsx
export function ATModifiersDisplay({ archetype, className }: ATModifiersDisplayProps) {
  if (!archetype) {
    return (
      <div className="text-muted-foreground">
        Select an archetype to view base modifiers.
      </div>
    );
  }

  const modifiers = [
    {
      name: 'Base HP (Level 50)',
      value: archetype.baseHP,
      format: (val: number) => val.toFixed(1),
    },
    {
      name: 'Base Regeneration',
      value: archetype.baseRegen,
      format: (val: number) => `${(val * 100).toFixed(2)}%/s`,
    },
    {
      name: 'Base Recovery',
      value: archetype.baseRecovery,
      format: (val: number) => `${(val * 100).toFixed(2)}%/s`,
    },
    {
      name: 'Base Threat',
      value: archetype.baseThreat,
      format: (val: number) => `${(val * 100).toFixed(0)}%`,
    },
  ];

  return (
    <div className={cn('rounded-lg border', className)}>
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Modifier</TableHead>
            <TableHead className="text-right">Value</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {modifiers.map((mod) => (
            <TableRow key={mod.name}>
              <TableCell className="font-medium">{mod.name}</TableCell>
              <TableCell className="text-right font-mono">
                {mod.format(mod.value)}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
```

**Data Requirements**:
- Archetype type must include:
  ```typescript
  interface Archetype {
    // ... existing fields
    baseHP: number;        // Base HP at level 50
    baseRegen: number;     // Base regeneration (decimal, e.g., 0.02 = 2%/s)
    baseRecovery: number;  // Base recovery (decimal, e.g., 0.0167 = 1.67%/s)
    baseThreat: number;    // Base threat/aggro (decimal, e.g., 1.0 = 100%)
  }
  ```

**Tests**:
1. Renders table with 4 base modifiers
2. Formats values correctly (HP as number, others as percentages)
3. Displays different values for different archetypes
4. Shows placeholder when no archetype selected
5. Updates when archetype changes

---

### 4. CapsDisplay.tsx (Archetype Caps Table)

**Purpose**: Display archetype caps for defense, resistance, damage, HP, regen, recovery, recharge

**Props Interface**:
```typescript
interface CapsDisplayProps {
  archetype: Archetype | null;
  className?: string;
}
```

**Component Structure**:
```tsx
export function CapsDisplay({ archetype, className }: CapsDisplayProps) {
  if (!archetype) {
    return (
      <div className="text-muted-foreground">
        Select an archetype to view caps.
      </div>
    );
  }

  const caps = [
    {
      name: 'HP Cap',
      value: archetype.hpCap,
      format: (val: number) => `${(val * 100).toFixed(0)}%`,
      description: 'Maximum HP increase from base',
    },
    {
      name: 'Damage Cap',
      value: archetype.damageCap,
      format: (val: number) => `${(val * 100).toFixed(0)}%`,
      description: 'Maximum damage buff',
    },
    {
      name: 'Resistance Cap',
      value: archetype.resistanceCap,
      format: (val: number) => `${(val * 100).toFixed(0)}%`,
      description: 'Maximum damage resistance',
    },
    {
      name: 'Defense Cap (Display)',
      value: archetype.defenseCap,
      format: (val: number) => `${(val * 100).toFixed(0)}%`,
      description: 'Maximum defense (display only, soft cap is 45%)',
    },
    {
      name: 'Regeneration Cap',
      value: archetype.regenCap,
      format: (val: number) => `${(val * 100).toFixed(0)}%`,
      description: 'Maximum regeneration increase',
    },
    {
      name: 'Recovery Cap',
      value: archetype.recoveryCap,
      format: (val: number) => `${(val * 100).toFixed(0)}%`,
      description: 'Maximum recovery increase',
    },
    {
      name: 'Recharge Cap',
      value: archetype.rechargeCap,
      format: (val: number) => `${(val * 100).toFixed(0)}%`,
      description: 'Maximum recharge reduction',
    },
  ];

  return (
    <div className={cn('rounded-lg border', className)}>
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Cap Type</TableHead>
            <TableHead className="text-right">Value</TableHead>
            <TableHead>Description</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {caps.map((cap) => (
            <TableRow key={cap.name}>
              <TableCell className="font-medium">{cap.name}</TableCell>
              <TableCell className="text-right font-mono">
                {cap.format(cap.value)}
              </TableCell>
              <TableCell className="text-sm text-muted-foreground">
                {cap.description}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
```

**Data Requirements**:
- Archetype type must include:
  ```typescript
  interface Archetype {
    // ... existing fields
    hpCap: number;         // HP cap (decimal, e.g., 2.0 = 200%)
    damageCap: number;     // Damage cap (decimal, e.g., 7.75 = 775%)
    resistanceCap: number; // Resistance cap (decimal, e.g., 0.9 = 90%)
    defenseCap: number;    // Defense cap (decimal, e.g., 2.25 = 225%)
    regenCap: number;      // Regen cap (decimal, e.g., 30.0 = 3000%)
    recoveryCap: number;   // Recovery cap (decimal, e.g., 6.0 = 600%)
    rechargeCap: number;   // Recharge cap (decimal, e.g., 4.0 = 400%)
  }
  ```

**Tests**:
1. Renders table with 7 cap types
2. Formats all values as percentages
3. Shows description tooltips
4. Displays different caps for different archetypes (e.g., Tanker vs Blaster)
5. Shows placeholder when no archetype selected
6. Updates when archetype changes

---

### 5. InherentPowersDisplay.tsx (Inherent Powers List)

**Purpose**: Display archetype inherent powers with icons and descriptions

**Props Interface**:
```typescript
interface InherentPowersDisplayProps {
  archetype: Archetype | null;
  className?: string;
}
```

**Component Structure**:
```tsx
export function InherentPowersDisplay({ archetype, className }: InherentPowersDisplayProps) {
  const { data: inherentPowers, isLoading, error } = useInherentPowers(
    archetype?.id
  );

  if (!archetype) {
    return (
      <div className="text-muted-foreground">
        Select an archetype to view inherent powers.
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-8">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-destructive">
        Error loading inherent powers: {error.message}
      </div>
    );
  }

  if (!inherentPowers || inherentPowers.length === 0) {
    return (
      <div className="text-muted-foreground">
        No inherent powers for this archetype.
      </div>
    );
  }

  // Sort by priority (MidsReborn behavior)
  const sortedPowers = [...inherentPowers].sort(
    (a, b) => (a.priority || 0) - (b.priority || 0)
  );

  return (
    <div className={cn('space-y-2', className)}>
      {sortedPowers.map((power) => (
        <div
          key={power.id}
          className="flex items-start gap-4 p-3 rounded-lg border bg-card hover:bg-accent transition-colors"
        >
          {/* Power Icon */}
          <div className="flex-shrink-0 w-12 h-12 rounded bg-muted flex items-center justify-center">
            {power.iconUrl ? (
              <Image
                src={power.iconUrl}
                alt={power.displayName}
                width={48}
                height={48}
                className="rounded"
              />
            ) : (
              <ZapIcon className="h-6 w-6 text-muted-foreground" />
            )}
          </div>

          {/* Power Info */}
          <div className="flex-1 space-y-1">
            <div className="flex items-center justify-between">
              <h4 className="font-semibold">{power.displayName}</h4>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="ghost" size="sm">
                      <InfoIcon className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent side="left" className="max-w-md">
                    <p className="text-sm">{power.description}</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
            <p className="text-sm text-muted-foreground line-clamp-2">
              {power.description}
            </p>
          </div>
        </div>
      ))}
    </div>
  );
}
```

**State Management**:
- Uses `useInherentPowers` hook (TanStack Query) to fetch inherent powers
- No local state (all data from API)

**Tests**:
1. Fetches inherent powers from API when archetype selected
2. Displays powers in priority order
3. Shows power icons (or fallback icon)
4. Shows power name and description
5. Displays tooltip on info button hover
6. Shows loading state while fetching
7. Shows error state on API failure
8. Shows placeholder when no archetype selected
9. Updates when archetype changes

---

## State Management Plan

### TanStack Query

**useInherentPowers Hook**:
```typescript
// hooks/useInherentPowers.ts
export function useInherentPowers(archetypeId: number | undefined) {
  return useQuery({
    queryKey: ['inherent-powers', archetypeId],
    queryFn: async () => {
      if (!archetypeId) return [];
      const response = await fetch(
        `/api/archetypes/${archetypeId}/powersets?powerset_type=inherent`
      );
      if (!response.ok) {
        throw new Error('Failed to fetch inherent powers');
      }
      const data = await response.json();
      // Extract powers from inherent powerset
      return data.powers || [];
    },
    enabled: !!archetypeId,
    staleTime: Infinity, // Static game data
  });
}
```

### Zustand (characterStore)

No changes needed to characterStore - all required state already exists from Epic 2.1:
- `name: string`
- `level: number`
- `archetype: Archetype | null`
- `origin: Origin | null`
- `alignment: Alignment | null`

Actions already exist:
- `setName(name: string)`
- `setLevel(level: number)`

### Derived State

All derived from `archetype`:
- Inherent powers: fetched via `useInherentPowers(archetype.id)`
- AT modifiers: read from `archetype.baseHP`, `archetype.baseRegen`, etc.
- Caps: read from `archetype.hpCap`, `archetype.damageCap`, etc.

---

## API Integration Plan

### Backend Endpoints

#### 1. GET /api/archetypes/{id}

**Status**: ✅ Already implemented in backend

**Enhancement Required**: ⚠️ Add cap and modifier fields to Archetype schema

**Current Response** (simplified):
```json
{
  "id": 1,
  "name": "Blaster",
  "displayName": "Blaster",
  "description": "...",
  "primaryPowersets": [...],
  "secondaryPowersets": [...]
}
```

**Required Additional Fields**:
```json
{
  "id": 1,
  "name": "Blaster",
  "displayName": "Blaster",

  // Base modifiers (NEW)
  "baseHP": 1204.8,
  "baseRegen": 0.02,
  "baseRecovery": 0.0167,
  "baseThreat": 1.0,

  // Caps (NEW)
  "hpCap": 1.606,
  "damageCap": 5.0,
  "resistanceCap": 0.75,
  "defenseCap": 2.25,
  "regenCap": 30.0,
  "recoveryCap": 6.0,
  "rechargeCap": 4.0
}
```

**Backend Implementation**:
- Caps data already exists in `backend/app/calculations/core/archetype_caps.py`
- Need to add fields to Archetype SQLAlchemy model
- Update archetype API response schema

#### 2. GET /api/archetypes/{id}/powersets?powerset_type=inherent

**Status**: ✅ Already implemented in backend

**Response** (simplified):
```json
{
  "id": 123,
  "name": "Blaster.Blaster_Inherent",
  "displayName": "Blaster Inherent",
  "type": "Inherent",
  "powers": [
    {
      "id": 456,
      "name": "Defiance",
      "displayName": "Defiance",
      "description": "As you lose health, your damage and mez resistance increase.",
      "iconUrl": "/icons/powers/defiance.png",
      "priority": 1
    }
  ]
}
```

**No changes needed** - endpoint already returns inherent powers correctly.

### TypeScript Types

**Update Archetype Type**:
```typescript
// types/character.types.ts
export interface Archetype {
  id: number;
  name: string;
  displayName: string;
  description: string;

  // Existing fields
  primaryPowersets: Powerset[];
  secondaryPowersets: Powerset[];

  // NEW: Base modifiers
  baseHP: number;
  baseRegen: number;
  baseRecovery: number;
  baseThreat: number;

  // NEW: Caps
  hpCap: number;
  damageCap: number;
  resistanceCap: number;
  defenseCap: number;
  regenCap: number;
  recoveryCap: number;
  rechargeCap: number;
}
```

**Power Type** (for inherent powers):
```typescript
// types/power.types.ts
export interface Power {
  id: number;
  name: string;
  displayName: string;
  description: string;
  iconUrl?: string;
  priority?: number;  // For sorting inherent powers
  // ... other fields
}
```

### Error Handling

All API calls wrapped in try/catch with error states:
```typescript
if (error) {
  return <ErrorMessage error={error} />;
}
```

Loading states:
```typescript
if (isLoading) {
  return <LoadingSpinner />;
}
```

---

## Implementation Tasks

### Task 1: Backend API Enhancement
**Time**: 2-3 hours

1. Add cap fields to Archetype SQLAlchemy model
   - Location: `backend/app/models.py:Archetype`
   - Fields: hpCap, damageCap, resistanceCap, defenseCap, regenCap, recoveryCap, rechargeCap
2. Add base modifier fields to Archetype model
   - Fields: baseHP, baseRegen, baseRecovery, baseThreat
3. Update archetype API schema to include new fields
   - Location: `backend/app/schemas.py:ArchetypeSchema`
4. Populate cap data from `archetype_caps.py` into database
   - Migration script or seed data update
5. Test: GET /api/archetypes/{id} returns caps and modifiers

### Task 2: TypeScript Types Update
**Time**: 30 minutes

1. Update Archetype interface in `types/character.types.ts`
   - Add cap fields
   - Add base modifier fields
2. Ensure Power interface includes priority field

### Task 3: Create Custom Hook
**Time**: 1 hour

1. Create `hooks/useInherentPowers.ts`
   - TanStack Query hook
   - Fetches inherent powers by archetype ID
   - Returns sorted by priority
2. Write tests for useInherentPowers
   - Fetches data correctly
   - Sorts by priority
   - Handles errors
   - Handles loading state

### Task 4: Create ATModifiersDisplay Component
**Time**: 2 hours

1. Create `components/character/ATModifiersDisplay.tsx`
   - Table component showing 4 base modifiers
   - Proper formatting (HP as number, others as percentages)
2. Write tests for ATModifiersDisplay
   - Renders table correctly
   - Formats values correctly
   - Shows placeholder when no archetype
   - Updates on archetype change

### Task 5: Create CapsDisplay Component
**Time**: 2 hours

1. Create `components/character/CapsDisplay.tsx`
   - Table component showing 7 cap types
   - Descriptions for each cap
   - Proper formatting (all as percentages)
2. Write tests for CapsDisplay
   - Renders all 7 caps
   - Formats values correctly
   - Shows tooltips/descriptions
   - Different values for different ATs
   - Updates on archetype change

### Task 6: Create InherentPowersDisplay Component
**Time**: 3 hours

1. Create `components/character/InherentPowersDisplay.tsx`
   - List/card layout for inherent powers
   - Power icons (with fallback)
   - Power descriptions
   - Tooltip on hover
   - Uses useInherentPowers hook
2. Write tests for InherentPowersDisplay
   - Fetches and displays inherent powers
   - Sorts by priority
   - Shows icons
   - Shows descriptions
   - Tooltips work
   - Loading state
   - Error state
   - Empty state

### Task 7: Create CharacterSummary Component
**Time**: 2-3 hours

1. Create `components/character/CharacterSummary.tsx`
   - MidsReborn format summary display
   - Edit mode for name and level
   - View mode with edit button
   - Input validation (level 1-50)
2. Write tests for CharacterSummary
   - Displays summary in correct format
   - Enters edit mode
   - Updates name in store
   - Updates level in store (validates 1-50)
   - Exits edit mode
   - Handles missing data

### Task 8: Create CharacterSheet Component
**Time**: 2 hours

1. Create `components/character/CharacterSheet.tsx`
   - Main container with Card
   - Tabs for modifiers, caps, inherents
   - Composes all subcomponents
   - Passes mode prop down
2. Write tests for CharacterSheet
   - Renders all subcomponents
   - Switches between tabs
   - Updates when store changes
   - Handles null archetype

### Task 9: Integration & Visual Testing
**Time**: 2-3 hours

1. Add CharacterSheet to builder page
   - Location: `app/builder/page.tsx` or appropriate page
   - Position: Side panel or dedicated section
2. Test full integration
   - Select archetype → see caps/modifiers/inherents
   - Edit name/level → persists to store
   - Switch tabs → all data displays correctly
3. Visual verification
   - Compare with MidsReborn screenshots
   - Ensure layout is intuitive
   - Mobile/tablet responsive

### Task 10: Documentation & Cleanup
**Time**: 1 hour

1. Update component documentation
2. Add JSDoc comments
3. Update CHANGELOG.md
4. Code review and cleanup

---

## Acceptance Criteria

### Functional

✅ Character summary displays in MidsReborn format: `"{Name}: Level {level} {Origin} {Archetype} ({Primary} / {Secondary})"`
✅ Character name and level are editable in edit mode
✅ Archetype base modifiers display correctly (HP, regen, recovery, threat)
✅ Archetype caps display correctly (7 cap types)
✅ Inherent powers list displays with icons and descriptions
✅ All data updates when archetype changes
✅ All data persists across page refreshes (from characterStore)

### Visual

✅ Components match MidsReborn functional layout (not pixel-perfect)
✅ Modern web aesthetic with shadcn/ui components
✅ Tables are easy to read with proper formatting
✅ Inherent powers list is visually appealing
✅ Responsive on mobile/tablet/desktop
✅ Smooth transitions and interactions

### Technical

✅ All TypeScript strict mode compliant (no `any`)
✅ All components have tests (>80% coverage)
✅ All tests passing
✅ ESLint and Prettier passing
✅ No console errors or warnings
✅ TanStack Query caching working correctly
✅ Backend API returns caps and modifiers

---

## Visual Verification Checklist

### Compare with MidsReborn

1. **Character Summary Format**
   - MidsReborn: `"{Name}: Level {level} {Origin} {Archetype} ({Primary} / {Secondary})"`
   - Our implementation: Same format

2. **Base Modifiers**
   - MidsReborn: Shows HP, regen, recovery, threat
   - Our implementation: Same data in table format

3. **Caps**
   - MidsReborn: Shows 7 cap types
   - Our implementation: Same 7 caps in table format

4. **Inherent Powers**
   - MidsReborn: List with icons in priority order
   - Our implementation: Cards with icons in priority order

### Screenshots for Verification

**Needed**:
1. `midsreborn-character-info-panel.png` - Full character sheet view
2. `midsreborn-archetype-caps.png` - Caps display
3. `midsreborn-inherent-powers.png` - Inherent powers list

**Available** (from /shared/user/midsreborn-screenshots):
- `mids-new-build.png` - May show character info panel

---

## Risks & Concerns

### Risk 1: Backend API Schema Change Required

**Impact**: High (blocks implementation)
**Mitigation**:
- Coordinate with backend team (or implement ourselves if owner)
- Simple addition of fields to existing model
- Data already exists in archetype_caps.py

### Risk 2: Inherent Powers API Response Format

**Impact**: Medium (may need API adjustment)
**Mitigation**:
- Test endpoint first to verify response format
- Adjust hook if needed to extract powers correctly

### Risk 3: Missing Archetype Data

**Impact**: Low (may have incomplete data)
**Mitigation**:
- Provide sensible defaults
- Show placeholder when data missing
- Log warnings for missing data

---

## Dependencies

### From Previous Epics

- ✅ Epic 1.2: CharacterStore foundation (name, level, archetype, origin)
- ✅ Epic 1.3: Layout components (Card, Tabs, Table)
- ✅ Epic 1.4: API client, TanStack Query setup
- ✅ Epic 2.1: Archetype selection, ArchetypeSelector component

### Backend API

- ⚠️ `GET /api/archetypes/{id}` - Needs enhancement with caps/modifiers
- ✅ `GET /api/archetypes/{id}/powersets?powerset_type=inherent` - Already implemented

### shadcn/ui Components

Required components (all should be installed):
- Card (container)
- Tabs (for modifiers/caps/inherents sections)
- Table (for caps and modifiers display)
- Input (for name/level editing)
- Button (for edit mode toggle)
- Tooltip (for inherent power descriptions)
- Label (for form fields)
- Icons (PencilIcon, InfoIcon, ZapIcon, Loader2)

---

## Next Epic Preview

**Epic 3.1**: Available Powers Panel

Epic 2.3 provides the character sheet foundation:
- ✅ Character info displayed
- ✅ Archetype data accessible
- ✅ Inherent powers shown

**Next steps**:
- Epic 3.1: Display available powers from selected powersets
- Epic 3.2: Power picker UI for build creation
- Epic 3.3: Enhancement browser
- Epic 3.4: Slot editor and enhancement picker

**Prerequisites Met**:
- ✅ Character fully configured (archetype, origin, powersets)
- ✅ CharacterStore ready for power selection
- ✅ Layout ready for power picker panels

---

## Summary

Epic 2.3 delivers character sheet display for Mids Hero Web:
- **4 React components** for character info, caps, modifiers, inherent powers
- **CharacterSummary** with edit mode for name/level
- **ATModifiersDisplay** showing base HP, regen, recovery, threat
- **CapsDisplay** showing 7 archetype caps
- **InherentPowersDisplay** showing archetype inherent powers
- **State management** via Zustand characterStore (read-only) + TanStack Query for inherent powers
- **API integration** via TanStack Query (requires backend enhancement for caps/modifiers)
- **~25 tests** covering all components and hooks

The implementation closely follows MidsReborn's character sheet display while adding modern web UX enhancements (tabs, cards, responsive design, better formatting).

---

**Status**: ✅ Planning Complete - Ready for Execution
**Components**: 4 React components + 1 custom hook
**Tests**: ~25 tests
**Estimated Time**: 16-20 hours
**Dependencies**: Backend API enhancement required (2-3 hours)
**Next**: Execute plan via implementation
